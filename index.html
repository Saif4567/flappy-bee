<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy Bee â€” GENSYN</title>
<style>
  html,body { height:100%; margin:0; background:#0b0b0b; }
  body { font-family: Arial, Helvetica, sans-serif; overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; }
  #shareBtn {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #1DA1F2;
    color: white;
    padding: 10px 18px;
    border-radius: 8px;
    display: none;
    font-size: 16px;
    cursor: pointer;
    z-index: 10;
  }
  #hint { position:absolute; top:10px; left:10px; color:white; font-size:18px; user-select:none; z-index:10; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hint">Score: <span id="sc">0</span></div>
<button id="shareBtn">Share Score on X</button>

<script>
// ---------- Canvas setup ----------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;
function resize() {
  DPR = window.devicePixelRatio || 1;
  canvas.width = Math.floor(window.innerWidth * DPR);
  canvas.height = Math.floor(window.innerHeight * DPR);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener('resize', resize);
resize();

// ---------- Game state ----------
let running = false;
let gameOver = false;
let score = 0;
document.getElementById('sc').innerText = score;

// physics
const gravity = 0.55;
const jumpPower = -9;
const pipeSpeed = 3.2;

// ---------- Pixel Bee (mirrored for left-facing) ----------
/*
 Pixel map: 0=transparent,1=yellow,2=black,3=white(wing)
 Using mirrored map so bee faces LEFT and full-body visible.
*/
const beePixel = [
  [0,0,0,1,1,1,1,1,1,0,0],
  [0,0,1,1,1,1,1,1,1,1,0],
  [0,1,1,2,1,1,1,1,2,1,1],
  [0,1,1,2,1,3,3,1,2,1,1],
  [0,1,1,2,1,1,1,1,2,1,1],
  [0,0,1,1,1,1,1,1,1,1,0],
  [0,0,0,1,1,1,1,1,1,0,0],
  [0,0,0,2,2,0,2,2,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0]
];
// palette
const palette = { 1: '#FFD54A', 2: '#111111', 3: '#FFFFFF' };

// scale (medium-ish, slightly larger so whole bee visible)
let scaleBee = Math.max(3.8, Math.round((window.innerWidth / 1200) * 4.2));

// bee object (shifted right so full figure visible)
const bee = {
  x: Math.max(160, Math.floor(window.innerWidth * 0.12)),
  y: canvas.height / DPR / 2,
  vy: 0,
  w: beePixel[0].length * scaleBee,
  h: beePixel.length * scaleBee
};

// pipes
let pipes = [];
const pipeGap = Math.max(120, Math.min(220, Math.floor((canvas.height/DPR) * 0.22)));
const pipeWidth = 72;

// background scroll control
let bgX = 0;

// ---------- Sounds ----------
const flapSound = new Audio('https://cdn.pixabay.com/audio/2022/03/15/audio_a6bbc71c66.mp3');
const pointSound = new Audio('https://cdn.pixabay.com/audio/2022/03/15/audio_1e44b81e9f.mp3');
const dieSound = new Audio('https://cdn.pixabay.com/audio/2022/03/15/audio_4a8df21f69.mp3');
flapSound.volume = 0.7; pointSound.volume = 0.7; dieSound.volume = 0.7;

// controls
function flap() {
  if (!running) { running = true; return; }
  if (gameOver) return;
  bee.vy = jumpPower;
  try { flapSound.currentTime = 0; flapSound.play(); } catch(e){}
}
window.addEventListener('keydown', e => { if (e.code === 'Space' || e.code === 'ArrowUp') flap(); });
window.addEventListener('touchstart', e => { e.preventDefault(); flap(); }, {passive:false});
window.addEventListener('mousedown', flap);

// spawn pipes
function spawnPipe() {
  const top = 60 + Math.random() * (canvas.height/DPR - pipeGap - 120);
  pipes.push({ x: canvas.width/DPR + 40, top: top, passed:false });
}
setInterval(() => { if (running && !gameOver) spawnPipe(); }, 1600);

// ---------- Drawing helpers ----------
function drawRoundedRect(x,y,w,h,r,col) {
  ctx.fillStyle = col;
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.fill();
}

// draw dark-brown gradient background + hills + center GENSYN
function drawBackground() {
  const w = canvas.width/DPR, h = canvas.height/DPR;

  // dark-brown gradient (option 2)
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0, '#2e1c0f');
  g.addColorStop(0.55, '#1f140c');
  g.addColorStop(1, '#1b120b');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);

  // subtle hills/lighting
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  ctx.beginPath();
  ctx.ellipse(w*0.35, h*0.85, w*0.9, h*0.42, Math.PI/8, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(w*0.82, h*0.95, w*0.7, h*0.45, -Math.PI/10, 0, Math.PI*2);
  ctx.fill();

  // faint vertical stripes for subtle texture
  const tile = 20;
  for (let x = - (bgX % tile); x < w+tile; x += tile) {
    ctx.fillStyle = 'rgba(0,0,0,0.02)';
    ctx.fillRect(x, 0, tile/2, h);
  }
  bgX -= 0.3;
  if (bgX < -tile) bgX = 0;

  // center GENSYN (darker-beige-ish to blend)
  ctx.fillStyle = 'rgba(184,142,90,0.16)'; // soft beige in dark brown
  ctx.font = "bold 120px Arial Black";
  ctx.textAlign = 'center';
  ctx.fillText('GENSYN', w/2, h/2 + 10);

  // small pixel-corner decorations
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillRect(18,18,6,6);
  ctx.fillRect(24,18,6,6);
  ctx.fillRect(18,24,6,6);
  ctx.fillRect(w-32, h-32, 6,6);
  ctx.fillRect(w-26, h-32, 6,6);
  ctx.fillRect(w-32, h-26, 6,6);
}

// draw the mirrored left-facing pixel bee
function drawBee(x,y) {
  const px = scaleBee;
  // shadow ellipse
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.beginPath();
  ctx.ellipse(x + (beePixel[0].length*px)/2, y + beePixel.length*px + 8, (beePixel[0].length*px)/1.7, px*1.7, 0,0,Math.PI*2);
  ctx.fill();

  // draw pixels (already mirrored ordering gives left-facing look)
  for (let ry=0; ry<beePixel.length; ry++) {
    for (let rx=0; rx<beePixel[0].length; rx++) {
      const v = beePixel[ry][rx];
      if (!v) continue;
      ctx.fillStyle = palette[v] || '#000';
      ctx.fillRect(Math.round(x + rx*px), Math.round(y + ry*px), Math.ceil(px), Math.ceil(px));
      if (v === 3) {
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        ctx.strokeRect(Math.round(x + rx*px), Math.round(y + ry*px), Math.ceil(px), Math.ceil(px));
      }
    }
  }
  // small wing shine
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.fillRect(x + px*3.6, y + px*1.2, px*2, px*1);
}

// draw pipes + ants pattern
function drawPipes() {
  const w = canvas.width/DPR, h = canvas.height/DPR;
  pipes.forEach(pipe => {
    ctx.fillStyle = '#ffb6c1';
    // top
    ctx.fillRect(pipe.x, 0, pipeWidth, pipe.top);
    // bottom
    ctx.fillRect(pipe.x, pipe.top + pipeGap, pipeWidth, h - (pipe.top + pipeGap));

    // ants: tiny rectangles across pipe surface
    const antSize = 3;
    const spacing = 8;
    ctx.fillStyle = '#1c1b1b';
    for (let yy = 8; yy < pipe.top - 4; yy += spacing) {
      for (let ax = 4 + ((yy/spacing)%2)*4; ax < pipeWidth; ax += spacing) {
        ctx.fillRect(Math.round(pipe.x + ax), Math.round(yy), antSize, antSize);
      }
    }
    for (let yy = pipe.top + pipeGap + 8; yy < h - 4; yy += spacing) {
      for (let ax = 4 + ((yy/spacing)%2)*4; ax < pipeWidth; ax += spacing) {
        ctx.fillRect(Math.round(pipe.x + ax), Math.round(yy), antSize, antSize);
      }
    }
    // subtle left-edge shadow
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    ctx.fillRect(pipe.x, 0, 6, pipe.top);
    ctx.fillRect(pipe.x, pipe.top + pipeGap, 6, h - (pipe.top + pipeGap));
  });
}

// ---------- Update & Collision ----------
function update(dt) {
  if (!running || gameOver) return;
  bee.vy += gravity;
  bee.y += bee.vy;

  for (let i = pipes.length-1; i >=0; i--) {
    pipes[i].x -= pipeSpeed;
    // scoring
    if (!pipes[i].passed && pipes[i].x + pipeWidth < bee.x + 8) {
      pipes[i].passed = true;
      score++;
      document.getElementById('sc').innerText = score;
      try { pointSound.currentTime = 0; pointSound.play(); } catch(e){}
    }
    if (pipes[i].x + pipeWidth < -40) pipes.splice(i,1);
  }

  // collision detection (approx using bounding box)
  for (let p of pipes) {
    const left = p.x, right = p.x + pipeWidth;
    const top = p.top, bottom = p.top + pipeGap;
    const bx = bee.x, by = bee.y;
    const bw = beePixel[0].length * scaleBee;
    const bh = beePixel.length * scaleBee;
    if (bx + bw*0.15 < right && bx + bw*0.85 > left) {
      if (by < top || by + bh > bottom) {
        triggerGameOver();
      }
    }
  }
  // top & bottom bounds
  if (bee.y < -10 || bee.y + beePixel.length*scaleBee > canvas.height/DPR + 8) {
    triggerGameOver();
  }
}

function triggerGameOver() {
  if (gameOver) return;
  gameOver = true;
  try { dieSound.currentTime = 0; dieSound.play(); } catch(e){}
  document.getElementById('shareBtn').style.display = 'block';
  // let user see then allow restart
}

// ---------- Render ----------
function render() {
  const w = canvas.width/DPR, h = canvas.height/DPR;
  // clear + background
  drawBackground();
  // pipes behind
  drawPipes();
  // draw bee slightly raised for nicer look
  drawBee(bee.x, bee.y);
  // start hint
  if (!running && !gameOver) {
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Tap/Space to Start â€” Flappy Bee', w/2, h*0.6 + 140);
  }
  if (gameOver) {
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.font = '48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', w/2, h/2);
    ctx.font = '22px Arial';
    ctx.fillText(`Score: ${score}`, w/2, h/2 + 40);
  }
}

// ---------- Main loop ----------
let last = performance.now();
function loop(t) {
  const dt = t - last;
  last = t;
  update(dt/1000);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ---------- Init & helpers ----------
function resetGame() {
  running = false; gameOver = false; score = 0;
  document.getElementById('sc').innerText = score;
  bee.y = canvas.height/DPR/2; bee.vy = 0;
  pipes = [];
}
resetGame();
setTimeout(() => spawnPipe(), 700);

// spawn periodic
setInterval(() => { if (running && !gameOver) spawnPipe(); }, 1600);

// share
document.getElementById('shareBtn').addEventListener('click', () => {
  const msg = encodeURIComponent(`I scored ${score} in Flappy Bee! ðŸðŸ”¥`);
  window.open(`https://twitter.com/intent/tweet?text=${msg}`, '_blank');
});

// restart on input after game over
window.addEventListener('keydown', e => {
  if (gameOver && (e.code === 'Space' || e.code === 'Enter')) resetGame();
});
window.addEventListener('touchstart', () => {
  if (gameOver) resetGame();
});

// pause with P
window.addEventListener('keydown', e => { if (e.key === 'p' || e.key === 'P') running = !running; });

// adjust bee scale on resize for consistent medium size
window.addEventListener('resize', () => {
  scaleBee = Math.max(3.8, Math.round((window.innerWidth / 1200) * 4.2));
  bee.w = beePixel[0].length * scaleBee;
  bee.h = beePixel.length * scaleBee;
  bee.x = Math.max(160, Math.floor(window.innerWidth * 0.12));
});

</script>
</body>
</html>
